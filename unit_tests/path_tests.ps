%% Path tests

userdict /$unittest known not {(unit_tests/unittest.ps) run} if


gsave nulldevice

%% newpath %%
/newpath [] assert

%% currentpoint %%
10 50 moveto /currentpoint [10.0 50.0] assert newpath
    % currentpoint errors
    /currentpoint [/nocurrentpoint] assert


%% moveto %%
10 50 {moveto currentpoint} [10.0 50.0] assert newpath
    % moveto errors
    10 /moveto [10 /stackunderflow] assert
    () 50 /moveto [() 50 /typecheck] assert
    50.0 () /moveto [50.0 () /typecheck] assert

%% rmoveto %%
10 50 moveto 10 5 {rmoveto currentpoint} [20. 55.0] assert newpath
    % rmoveto errors
    10 /rmoveto [10 /stackunderflow] assert
    () 50 /rmoveto [() 50 /typecheck] assert
    50.0 () /rmoveto [50.0 () /typecheck] assert


%% lineto %%
0 0 moveto 10 50 {lineto currentpoint} [10.0 50.0] assert newpath
    % lineto errors
    10 /lineto [10 /stackunderflow] assert
    () 50 /lineto [() 50 /typecheck] assert
    50.0 () /lineto [50.0 () /typecheck] assert
    10 50 /lineto [10 50 /nocurrentpoint] assert


%% rlineto %%
10 50 moveto 10 5 {rlineto currentpoint} [20. 55.0] assert newpath
    % rlineto errors
    10 /rlineto [10 /stackunderflow] assert
    () 50 /rlineto [() 50 /typecheck] assert
    50.0 () /rlineto [50.0 () /typecheck] assert
    10 50 /rlineto [10 50 /nocurrentpoint] assert


%% curveto %%
10 50 moveto 1 2 3 4 5 6 {curveto currentpoint} [5.0 6.0] assert newpath
    % curveto errors
    1 2 3 4 5 /curveto [1 2 3 4 5 /stackunderflow] assert
    () 2 3 4 5 6 /curveto [() 2 3 4 5 6 /typecheck] assert
    1 () 3 4 5 6 /curveto [1 () 3 4 5 6 /typecheck] assert
    1 2 () 4 5 6 /curveto [1 2 () 4 5 6 /typecheck] assert
    1 2 3 () 5 6 /curveto [1 2 3 () 5 6 /typecheck] assert
    1 2 3 4 () 6 /curveto [1 2 3 4 () 6 /typecheck] assert
    1 2 3 4 5 () /curveto [1 2 3 4 5 () /typecheck] assert
    1 2 3 4 5 6 /curveto [1 2 3 4 5 6 /nocurrentpoint] assert


%% rcurveto %%
10 50 moveto 1 2 3 4 5 6 {rcurveto currentpoint} [15.0 56.0] assert newpath
    % curveto errors
    1 2 3 4 5 /rcurveto [1 2 3 4 5 /stackunderflow] assert
    () 2 3 4 5 6 /rcurveto [() 2 3 4 5 6 /typecheck] assert
    1 () 3 4 5 6 /rcurveto [1 () 3 4 5 6 /typecheck] assert
    1 2 () 4 5 6 /rcurveto [1 2 () 4 5 6 /typecheck] assert
    1 2 3 () 5 6 /rcurveto [1 2 3 () 5 6 /typecheck] assert
    1 2 3 4 () 6 /rcurveto [1 2 3 4 () 6 /typecheck] assert
    1 2 3 4 5 () /rcurveto [1 2 3 4 5 () /typecheck] assert
    1 2 3 4 5 6 /rcurveto [1 2 3 4 5 6 /nocurrentpoint] assert


%% closepath %%
10 10 moveto 10 20 lineto /closepath [] assert newpath


%% arct %%
% Basic arct functionality - right angle corner with radius 10
newpath 0 20 moveto 100 20 100 100 20 {arct} [] assert
stroke
% arct with current point  
newpath 50 50 moveto 100 50 100 100 20 {arct} [] assert
stroke
% arct errors
    10 20 30 40 /arct [10 20 30 40 /stackunderflow] assert
    () 20 30 40 50 /arct [() 20 30 40 50 /typecheck] assert
    10 () 30 40 50 /arct [10 () 30 40 50 /typecheck] assert
    10 20 () 40 50 /arct [10 20 () 40 50 /typecheck] assert
    10 20 30 () 50 /arct [10 20 30 () 50 /typecheck] assert
    10 20 30 40 () /arct [10 20 30 40 () /typecheck] assert
    10 20 30 40 50 /arct [10 20 30 40 50 /nocurrentpoint] assert
    % Collinear case should work (per PLRM) - creates straight line segment
    newpath 100 100 moveto 200 100 300 100 10 /arct [] assert
    stroke
    50 50 moveto 60 60 70 70 -5 /arct [] assert  % Negative radius

%% arcto %%
% Basic arcto functionality - should return tangent points on stack
    newpath 0 0 moveto 100 0 100 100 10 {arcto 4 {round 4 -1 roll} repeat} [90 0 100 10] assert
    stroke
    % arcto with different radius
    0 0 moveto 50 0 50 50 5 {arcto 4 {round 4 -1 roll} repeat} [45 0 50 5] assert
    stroke

% arcto errors (same as arct but returns values)
    10 20 30 40 /arcto [10 20 30 40 /stackunderflow] assert
    () 20 30 40 50 /arcto [() 20 30 40 50 /typecheck] assert
    10 () 30 40 50 /arcto [10 () 30 40 50 /typecheck] assert
    10 20 () 40 50 /arcto [10 20 () 40 50 /typecheck] assert
    10 20 30 () 50 /arcto [10 20 30 () 50 /typecheck] assert
    10 20 30 40 () /arcto [10 20 30 40 () /typecheck] assert
    10 20 30 40 50 /arcto [10 20 30 40 50 /nocurrentpoint] assert
    100 100 moveto 200 100 300 100 10 /arcto [200 100 200 100] assert  % collinear lines
    stroke showpage
    50 50 moveto 60 60 70 70 -5 /arcto [60 60 60 60] assert  % Negative radius
    stroke


%% reversepath %%

% Reverse empty path - no error
newpath /reversepath [] assert

% Reverse moveto-only path
newpath 10 20 moveto {reversepath currentpoint} [10.0 20.0] assert newpath

% Use identity CTM for reversepath coordinate tests to avoid iCTM round-trip precision loss
gsave matrix setmatrix

% Reverse simple open path (moveto + lineto), verify with pathforall
newpath 0 0 moveto 100 0 lineto 100 100 lineto
reversepath
% Reversed: moveto(100,100) lineto(100,0) lineto(0,0)
% Collect path elements via pathforall
[ {2 array astore} {2 array astore} {6 array astore} {} pathforall ]
% Should be: [[100 100] [100 0] [0 0]]
{
    dup length 3 eq                         % 3 elements
    1 index 0 get 0 get 100.0 eq and        % moveto x=100
    1 index 0 get 1 get 100.0 eq and        % moveto y=100
    1 index 1 get 0 get 100.0 eq and        % lineto1 x=100
    1 index 1 get 1 get 0.0 eq and          % lineto1 y=0
    1 index 2 get 0 get 0.0 eq and          % lineto2 x=0
    1 index 2 get 1 get 0.0 eq and          % lineto2 y=0
    exch pop
} [true] assert newpath

% Reverse closed path - closepath preserved at end
newpath 0 0 moveto 100 0 lineto 100 100 lineto closepath
reversepath
/closecount 0 def
{ pop pop } { pop pop } { 6 { pop } repeat } { /closecount closecount 1 add def } pathforall
closecount [1] assert newpath

% Reverse path with curveto - control points swapped
newpath 0 0 moveto 10 20 30 40 50 60 curveto
reversepath
% Reversed: moveto(50,60) curveto(cp2=30,40 cp1=10,20 endpoint=0,0)
% i.e., curveto with swapped control points: (30,40) (10,20) (0,0)
[ {2 array astore} {2 array astore} {6 array astore} {} pathforall ]
{
    dup length 2 eq                         % moveto + curveto = 2 elements
    1 index 0 get 0 get 50.0 eq and         % moveto x=50
    1 index 0 get 1 get 60.0 eq and         % moveto y=60
    1 index 1 get 0 get 30.0 eq and         % curveto cp1.x = original cp2.x
    1 index 1 get 1 get 40.0 eq and         % curveto cp1.y = original cp2.y
    1 index 1 get 2 get 10.0 eq and         % curveto cp2.x = original cp1.x
    1 index 1 get 3 get 20.0 eq and         % curveto cp2.y = original cp1.y
    1 index 1 get 4 get 0.0 eq and          % curveto endpoint.x = 0
    1 index 1 get 5 get 0.0 eq and          % curveto endpoint.y = 0
    exch pop
} [true] assert newpath

% Currentpoint after reversepath on open path
newpath 0 0 moveto 100 200 lineto
reversepath
{currentpoint} [0.0 0.0] assert newpath

% Currentpoint after reversepath on closed path
newpath 0 0 moveto 100 200 lineto closepath
reversepath
% After closepath, currentpoint should be the moveto point of the reversed subpath
{currentpoint} [100.0 200.0] assert newpath

grestore


%% infill %%
% Point inside a rectangle
newpath 100 100 moveto 200 100 lineto 200 200 lineto 100 200 lineto closepath
150 150 {infill} [true] assert newpath

% Point outside a rectangle
newpath 100 100 moveto 200 100 lineto 200 200 lineto 100 200 lineto closepath
50 50 {infill} [false] assert newpath

% Empty path returns false
newpath
150 150 {infill} [false] assert newpath

% Error conditions
150 /infill [150 /stackunderflow] assert
() 150 /infill [() 150 /typecheck] assert
150 () /infill [150 () /typecheck] assert


%% ineofill %%
% Point inside a simple rectangle (same result as infill)
newpath 100 100 moveto 200 100 lineto 200 200 lineto 100 200 lineto closepath
150 150 {ineofill} [true] assert newpath

% Point outside a rectangle
newpath 100 100 moveto 200 100 lineto 200 200 lineto 100 200 lineto closepath
50 50 {ineofill} [false] assert newpath

% Concentric rectangles â€” winding vs even-odd difference:
% Outer rect CW, inner rect also CW. Center point has winding=2 (inside for
% winding rule) but even-odd crossing count=2 (outside for even-odd rule).
newpath
0 0 moveto 300 0 lineto 300 300 lineto 0 300 lineto closepath
50 50 moveto 250 50 lineto 250 250 lineto 50 250 lineto closepath
150 150 {infill} [true] assert      % winding: inside (winding != 0)
150 150 {ineofill} [false] assert   % even-odd: outside (2 crossings = even)
newpath

% Empty path returns false
newpath
150 150 {ineofill} [false] assert newpath

% Error conditions
150 /ineofill [150 /stackunderflow] assert
() 150 /ineofill [() 150 /typecheck] assert
150 () /ineofill [150 () /typecheck] assert


%% instroke %%
% Point on a wide stroked horizontal line
newpath 100 100 moveto 200 100 lineto
10 setlinewidth
150 100 {instroke} [true] assert newpath

% Point well away from the stroked line
newpath 100 100 moveto 200 100 lineto
1 setlinewidth
150 200 {instroke} [false] assert newpath

% Empty path returns false
newpath
150 150 {instroke} [false] assert newpath

% Error conditions
150 /instroke [150 /stackunderflow] assert
() 150 /instroke [() 150 /typecheck] assert
150 () /instroke [150 () /typecheck] assert

grestore
